#!/usr/bin/perl -w

# landle: A Small but Useful(tm) utility to maintain clones of github
# repos.
#
# Copyright (C) 2014 Hugh Brown
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use Getopt::Std;
# use Net::GitHub::V3;
use Config::Simple;
use LWP::Simple;
use JSON::XS;
use File::Basename qw(dirname);
use File::HomeDir qw(home);
use File::Path qw(make_path);
use Log::Message::Simple qw(msg error debug carp croak cluck confess);
use Cwd qw(cwd abs_path);

my $version = "1.3";
my %option;
my $p_option;
my $verbose = 0;
my $offline = 0;
my $testing_only = 0;
my $data;
my $project;
my $user;
my $rcfile = ".landlerc";
my $rc;
my $cfg;
my $orig;
my @subdirs = qw(forks
		 mirrors
		 private
		 public
		 starred
		 watching);

sub usage {
	print <<USAGE;
$0: A Small but Useful(tm) utility to maintain clones of your github repos.

Usage:

-d	Work on already-downloaded test data in the current working directory; see below.
-v	Be verbose.
-f [file] Specify path to config file; by default, looks in cwd first, then home directory.
-n	Testing only: show, do not do.
-h	This helpful message.

See the README.md file for details on the config file format.

To use the -d option, fetch your Github info with wget:

    wget https://api.github.com/users/[username]/starred -O user.starred.json
    wget https://api.github.com/users/[username]/repos -O user.repos.json

Version: $version
USAGE
	exit 1;
}

sub complain_and_die {
	my $error = shift;
	carp("$error");
	&usage;
}

sub setup_root {
	# FIXME: eval / check for errors
	my $root = shift;
	debug("Setting up directories...", $verbose);
	foreach my $i (@subdirs) {
		next if -d "${root}/$i";
		make_path("${root}/$i", { verbose => $verbose,
					  mode    => 0755 });
	}
	debug("Done.", $verbose);
}

# FIXME: My variable names here are a mess.
sub clone_or_pull {
	my $args = shift;
	my $project = $args->{"project"};
	my $cfg = $args->{"cfg"};
	my $target_dir = $args->{"target_dir"};
	debug("Target dir: $target_dir", $verbose);
	debug("Repo dir: " . $cfg->{"landle.repodir"}, $verbose);
	chdir($cfg->{"landle.repodir"} . "/${target_dir}");
	my $repo_dir = $project->{"name"};
	if (-d $repo_dir) {
		debug("Assuming already cloned and need to update.", $verbose);
		# FIXME: Would git fetch be better?
		debug("cd $repo_dir && git pull origin master", $verbose);
		return if $testing_only;
		chdir("$repo_dir");
		system("git pull origin master");
	} else {
		debug("Assuming need to clone.", $verbose);
		chdir($cfg->{"landle.repodir"});
		my $clone = sprintf("git clone %s", $project->{"clone_url"});
		debug($clone, $verbose);
		# FIXME: This double check to see if we're in testing
		# mode seems...inelegant.
		if ($testing_only == 0) {
			system($clone);
		}
		if (defined ($cfg->{"landle.post-clone-hook"})) {
			debug("cd $target_dir && " . $cfg->{"landle.post-clone-hook"} , $verbose);
			return if $testing_only;
			chdir($target_dir);
			system($cfg->{"landle.post-clone-hook"});
		}
	}
}

getopts('dvf:nh', \%option);

if ($option{h}) {
	&usage;
}

if ($option{v}) {
	$verbose = 1;
}

if ($option{n}) {
	$testing_only = 1;
}
if (defined $option{d}) {
	$offline = 1;
}

# FIXME: Might want to use Config::Simple to do this; maybe we can do
# try/finally with it.
if ($option{f}) {
	$rc = $option{f};
	debug("Using $rc as directed.", $verbose);
} else {
	push my @possible, sprintf("%s/.landlerc", cwd());
	push    @possible, sprintf("%s/.landlerc", home());
	# FIXME: I'm not sure how best to do a "hey, none of that works" message.
	SEARCH: foreach my $i (@possible) {
		if (-f $i) {
			debug("Found $i, so using that.", $verbose);
			$rc = $i;
			last SEARCH;
		}
	}
}

debug("Reading config file $rc...", $verbose);
my %cfg = new Config::Simple($rc)->vars();
debug("Username: " . $cfg{"landle.user"},    $verbose);
debug("Repodir: "  . $cfg{"landle.repodir"}, $verbose);

setup_root($cfg{"landle.repodir"});

# Arghh:  repos and starred are different.
# FIXME: This handling of the original directory is stupid.
if ($offline == 1) {
	local $/;
	open(my $fh, '<', 'user.repos.json') or complain_and_die("Can't open user.repos.json: $!");
	$orig = dirname(abs_path('user.repos.json'));
	debug("Found user.repos.json in $orig, so will look there for user.starred.json as well.", $verbose);
	my $json_text = <$fh>;
	$data = decode_json($json_text);
	close($fh);
} else {
	my $url = sprintf("https://api.github.com/users/%s/repos", $cfg{"landle.user"});
	debug("Fetching $url", $verbose);
	my $reply = get($url);
	# debug("\$reply = |$reply|", $verbose);
	if (defined $reply) {
		push(@$data, @{decode_json($reply)});
	} else {
		complain_and_die("Can't fetch $url -- maybe try the -d option?");
	}
}

# users.repos will give us forks, private and public.

foreach $project (@$data) {
	# debug("Name: " . $project->{"name"}, $verbose);
	# debug("\tFork?: " . $project->{"fork"}, $verbose);
	# debug("\tClone URL: " . $project->{"clone_url"}, $verbose);
	if ($project->{"fork"} == 1) {
		clone_or_pull({ project	   => $project,
				cfg	   => \%cfg,
				target_dir => "forks"});
	} elsif ($project->{"private"} == 1) {
		clone_or_pull({ project	   => $project,
				cfg	   => \%cfg,
				target_dir => "private"});
	} else {
		clone_or_pull({ project	   => $project,
				cfg	   => \%cfg,
				target_dir => "public"});
	}
}

# And now starred.
if ($offline == 1) {
	chdir($orig);
	local $/;
	open(my $fh, '<', 'user.starred.json') or complain_and_die("Can't open user.starred.json: $!");
	my $json_text = <$fh>;
	$data = decode_json($json_text);
} else {
	my $url = sprintf("https://api.github.com/users/%s/starred", $cfg{"landle.user"});
	debug("Fetching $url", $verbose);
	my $reply = get($url);
	# debug("\$reply = |$reply|", $verbose);
	$data = decode_json($reply);
}

foreach $project (@$data) {
	clone_or_pull({ project	     => $project,
			  cfg	     => \%cfg,
			  target_dir => "starred"});
}
